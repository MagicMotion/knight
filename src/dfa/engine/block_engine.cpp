//===- block_engine.cpp -----------------------------------------------===//
//
// Copyright (c) 2024 Junjie Shen
//
// see https://github.com/shenjunjiekoda/knight/blob/main/LICENSE for
// license information.
//
//===------------------------------------------------------------------===//
//
//  This header defines the execution engine for the Basic Block.
//
//===------------------------------------------------------------------===//

#include "dfa/engine/block_engine.hpp"
#include "dfa/proc_cfg.hpp"
#include "dfa/analysis/analysis_base.hpp"
#include "util/assert.hpp"

namespace knight::dfa {

void BlockExecutionEngine::exec() {
    ProgramStateRef state = m_state;
    for (auto& elem : m_node->Elements) {
        using enum clang::CFGElement::Kind;
        switch (elem.getKind()) {
        default:
            break;
        case Initializer: {
            const auto& init = elem.castAs< clang::CFGInitializer >();
            exec_cxx_ctor_initializer(init.getInitializer());
        } break;
        case ScopeBegin: {
            const auto& scope_begin = elem.castAs< clang::CFGScopeBegin >();
            exec_scope_begin(scope_begin.getTriggerStmt(),
                             scope_begin.getVarDecl());
        } break;
        case ScopeEnd: {
            const auto& scope_end = elem.castAs< clang::CFGScopeEnd >();
            exec_scope_end(scope_end.getTriggerStmt(), scope_end.getVarDecl());
        } break;
        case NewAllocator: {
            const auto& new_allocator = elem.castAs< clang::CFGNewAllocator >();
            exec_new_allocator_call(new_allocator.getAllocatorExpr());
        } break;
        case LifetimeEnds: {
            const auto& lifetime_ends = elem.castAs< clang::CFGLifetimeEnds >();
            exec_lifetime_ends(lifetime_ends.getTriggerStmt(),
                               lifetime_ends.getVarDecl());
        } break;
        case LoopExit: {
            knight_unreachable("construct loop exit not implemented yet");
        } break;
        case Statement: {
            const auto& cfg_stmt = elem.castAs< clang::CFGStmt >();
            exec_cfg_stmt(cfg_stmt.getStmt(), state);
        } break;
        case Constructor: {
            knight_unreachable("constructor not implemented yet");
        } break;
        case AutomaticObjectDtor:
        case DeleteDtor:
        case BaseDtor:
        case MemberDtor:
        case TemporaryDtor: {
            knight_unreachable("destructors not implemented yet");
        } break;
        case CleanupFunction: {
            knight_unreachable("cleanup function not implemented yet");
        } break;
        }
    }
}

/// \brief Transfer C++ base or member initializer from constructor's initialization
/// list.
void BlockExecutionEngine::exec_cxx_ctor_initializer(
    clang::CXXCtorInitializer* initializer) {
    // todo
}

/// \brief Transfer beginning of a scope implicitly generated
/// by the compiler on encountering a CompoundStmt
///
/// \param trigger_stmt The CompoundStmt that triggers the scope
/// begin transfer.
/// \param var_decl The variable declaration that triggers the scope
/// begin transfer.
void BlockExecutionEngine::exec_scope_begin(StmtRef trigger_stmt,
                                            VarDeclRef var_decl) {
    // todo
}

/// \brief Transfer endding of a scope implicitly generated by
/// the compiler after the last Stmt in a CompoundStmt's body
void BlockExecutionEngine::exec_scope_end(StmtRef trigger_stmt,
                                          VarDeclRef var_decl) {
    // todo
}

/// \brief Transfer C++ new allocator call
void BlockExecutionEngine::exec_new_allocator_call(
    const clang::CXXNewExpr* expr) {
    // todo
}

/// \brief Transfer the point where the lifetime of an automatic object ends
void BlockExecutionEngine::exec_lifetime_ends(StmtRef trigger_stmt,
                                              VarDeclRef var_decl) {
    // todo
}

/// \brief Transfer the stmt
ProgramStateRef BlockExecutionEngine::exec_cfg_stmt(StmtRef stmt,
                                                    ProgramStateRef state) {
    state = state->clone();
    m_analysis_manager.get_analysis_context().set_state(state);
    m_stmt_post[stmt] = state;

    m_analysis_manager.run_analyses_for_pre_stmt(stmt);
    m_analysis_manager.run_analyses_for_eval_stmt(stmt);
    m_analysis_manager.run_analyses_for_post_stmt(stmt);

    auto post_state = m_analysis_manager.get_analysis_context().get_state();
    m_stmt_post[stmt] = post_state;
    return std::move(post_state);
}

} // namespace knight::dfa