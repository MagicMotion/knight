#!/usr/bin/python3

# ===- run-clang-tidy ------------------------------------------------===#
#
# Copyright (c) 2024 Junjie Shen
#
# see https://github.com/shenjunjiekoda/knight/blob/main/LICENSE for
# license information.
#
# ===------------------------------------------------------------------===#
#
#  This script runs clang-tidy on the whole repository using
#  compile_commands.json.
#
# ===------------------------------------------------------------------===#

import os
import argparse
import subprocess
import sys
from pathlib import Path
import json
from concurrent.futures import ThreadPoolExecutor


def find_clang_tidy(executable):
    """Find the clang-tidy executable in the PATH."""
    path = Path(executable)
    if path.is_file() and os.access(path, os.X_OK):
        return path
    for dir in map(Path, os.environ["PATH"].split(os.pathsep)):
        full_path = dir / executable
        if full_path.is_file() and os.access(full_path, os.X_OK):
            return full_path
    return None


def run_clang_tidy_on_file(
    clang_tidy, build_dir, file_path, header_filter, config_file
):
    """Run clang-tidy on a single file."""
    command = [
        str(clang_tidy),
        str(file_path),
        "-p",
        str(build_dir),
        "-header-filter=" + header_filter,
    ]
    if config_file:
        command.append(f"--config-file={config_file}")

    print(f"Running command: {' '.join(command)}")

    try:
        result = subprocess.run(command, check=True, capture_output=True, text=True)
        print(f"Standard Output for {file_path}:\n{result.stdout}")
        if result.stderr:
            print(f"Standard Error for {file_path}:\n{result.stderr}", file=sys.stderr)
    except subprocess.CalledProcessError as e:
        print(f"Error while processing {file_path}:\n{e.stderr}", file=sys.stderr)


def main():
    parser = argparse.ArgumentParser(
        description="Run clang-tidy on the whole repository using compile_commands.json"
    )
    parser.add_argument(
        "--build-dir",
        type=Path,
        default=Path(__file__).resolve().parent.parent / "build",
        help="Path to the build directory containing compile_commands.json",
    )
    parser.add_argument(
        "--clang-tidy", default="clang-tidy", help="Path to the clang-tidy binary"
    )
    parser.add_argument(
        "--config-file",
        type=Path,
        default=Path(__file__).resolve().parent.parent / ".clang-tidy",
        help="Path to the .clang-tidy config file",
    )
    parser.add_argument(
        "--header-filter",
        type=str,
        default="*knight*",
        help="Regex to specify which headers should be analyzed",
    )
    parser.add_argument(
        "-j",
        "--jobs",
        type=int,
        default=1,
        help="Number of tidy instances to be run in parallel.",
    )
    args = parser.parse_args()

    compile_commands_path = args.build_dir / "compile_commands.json"
    if not compile_commands_path.is_file():
        print(f"Error: '{compile_commands_path}' is not a file", file=sys.stderr)
        sys.exit(1)

    clang_tidy = find_clang_tidy(args.clang_tidy)
    if not clang_tidy:
        print(f"Error: '{args.clang_tidy}' not found in PATH", file=sys.stderr)
        sys.exit(1)

    # Read the compile_commands.json file
    with open(compile_commands_path) as f:
        compile_commands = json.load(f)

    # Extract the list of files to be processed
    files_to_process = [Path(entry["file"]) for entry in compile_commands]

    print("Starting clang-tidy scan for the following files:")
    for file in files_to_process:
        print(f" - {file}")

    # Run clang-tidy on each file using a thread pool
    with ThreadPoolExecutor(max_workers=args.jobs) as executor:
        futures = [
            executor.submit(
                run_clang_tidy_on_file,
                clang_tidy,
                args.build_dir,
                file_path,
                args.header_filter,
                args.config_file,
            )
            for file_path in files_to_process
        ]

        # Wait for all tasks to complete
        for future in futures:
            future.result()


if __name__ == "__main__":
    main()
